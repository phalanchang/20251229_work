# ログイン・ログアウト機能 要件定義書

## 1. 概要

本ドキュメントは、ログイン・ログアウト機能の要件定義を記載します。
ユーザーの操作フローとシステムの期待される動作をテストケース形式で定義しています。

## 2. 技術スタック

- **フロントエンド**: React
- **バックエンド**: Node.js
- **データベース**: MySQL
- **インフラ**: Docker Compose

## 3. 機能要件

### 3.1 ログイン機能

#### シナリオ1: 正常なログイン

**前提条件**
- ユーザーがシステムに登録済みである
- ユーザーは未ログイン状態である

**ユーザーの操作**
1. ログインページにアクセスする
2. 有効なメールアドレス（またはユーザー名）を入力する
3. 正しいパスワードを入力する
4. 「ログイン」ボタンをクリックする

**期待される動作**
- 入力された認証情報がバックエンドに送信される
- バックエンドがデータベースでユーザー情報を検証する
- 認証が成功した場合：
  - セッション（またはJWTトークン）が発行される
  - ユーザーはダッシュボード（またはホームページ）にリダイレクトされる
  - ログイン状態が保持される
  - ログイン成功の通知が表示される（オプション）

#### シナリオ2: ログイン失敗 - パスワード誤り

**前提条件**
- ユーザーがシステムに登録済みである
- ユーザーは未ログイン状態である

**ユーザーの操作**
1. ログインページにアクセスする
2. 有効なメールアドレス（またはユーザー名）を入力する
3. 誤ったパスワードを入力する
4. 「ログイン」ボタンをクリックする

**期待される動作**
- 入力された認証情報がバックエンドに送信される
- バックエンドがデータベースでユーザー情報を検証する
- 認証が失敗した場合：
  - エラーメッセージが表示される（例：「メールアドレスまたはパスワードが正しくありません」）
  - ログイン状態にならない
  - ログインページに留まる
  - パスワード入力欄がクリアされる（セキュリティのため）
  - メールアドレス入力欄は保持される（ユーザビリティのため）

#### シナリオ3: ログイン失敗 - ユーザー不存在

**前提条件**
- ユーザーは未ログイン状態である

**ユーザーの操作**
1. ログインページにアクセスする
2. 登録されていないメールアドレス（またはユーザー名）を入力する
3. 任意のパスワードを入力する
4. 「ログイン」ボタンをクリックする

**期待される動作**
- 入力された認証情報がバックエンドに送信される
- バックエンドがデータベースでユーザー情報を検証する
- ユーザーが存在しない場合：
  - エラーメッセージが表示される（セキュリティのため、パスワード誤りと同じメッセージを表示）
  - ログイン状態にならない
  - ログインページに留まる
  - パスワード入力欄がクリアされる

#### シナリオ4: ログイン失敗 - 入力検証エラー

**前提条件**
- ユーザーは未ログイン状態である

**ユーザーの操作**
1. ログインページにアクセスする
2. メールアドレス（またはユーザー名）を入力しない、または無効な形式を入力する
3. パスワードを入力しない、または短すぎるパスワードを入力する
4. 「ログイン」ボタンをクリックする

**期待される動作**
- クライアント側で入力検証が行われる
- 検証エラーがある場合：
  - 各入力欄に適切なエラーメッセージが表示される（例：「メールアドレスを入力してください」「パスワードは8文字以上で入力してください」）
  - ログインリクエストが送信されない
  - ログインページに留まる

#### シナリオ5: 既にログイン済みの状態でログインページにアクセス

**前提条件**
- ユーザーは既にログイン済みである

**ユーザーの操作**
1. ログインページのURLに直接アクセスする

**期待される動作**
- システムがログイン状態を検証する
- 既にログイン済みの場合：
  - ダッシュボード（またはホームページ）にリダイレクトされる
  - ログインページは表示されない

### 3.2 ログアウト機能

#### シナリオ6: 正常なログアウト

**前提条件**
- ユーザーはログイン済みである

**ユーザーの操作**
1. ログイン済みの状態でアプリケーションを使用している
2. 「ログアウト」ボタン（またはリンク）をクリックする

**期待される動作**
- ログアウトリクエストがバックエンドに送信される
- バックエンドがセッション（またはJWTトークン）を無効化する
- ログアウトが成功した場合：
  - クライアント側の認証情報が削除される
  - ユーザーはログインページにリダイレクトされる
  - ログアウト成功の通知が表示される（オプション）
  - ログインが必要なページにアクセスできなくなる

#### シナリオ7: セッションタイムアウト後のログアウト

**前提条件**
- ユーザーはログイン済みである
- セッションの有効期限が設定されている

**ユーザーの操作**
1. ログイン済みの状態でアプリケーションを使用している
2. 一定時間（例：30分）操作を行わない
3. その後、ページを操作しようとする

**期待される動作**
- システムがセッションの有効期限をチェックする
- セッションが期限切れの場合：
  - 自動的にログアウト処理が実行される
  - セッション期限切れの通知が表示される（例：「セッションが期限切れです。再度ログインしてください」）
  - ユーザーはログインページにリダイレクトされる

### 3.3 認証が必要なページへのアクセス

#### シナリオ8: 未ログイン状態で保護されたページにアクセス

**前提条件**
- ユーザーは未ログイン状態である
- アクセスしようとするページは認証が必要である

**ユーザーの操作**
1. 未ログイン状態で、認証が必要なページのURLに直接アクセスする（例：ダッシュボード、プロフィールページなど）

**期待される動作**
- システムが認証状態をチェックする
- 未ログインの場合：
  - アクセスが拒否される
  - ユーザーはログインページにリダイレクトされる
  - 元のページのURLが保持され、ログイン後にそのページにリダイレクトされる（オプション）
  - 適切なメッセージが表示される（例：「このページにアクセスするにはログインが必要です」）

#### シナリオ9: ログイン後に元のページにリダイレクト

**前提条件**
- ユーザーは未ログイン状態である
- ユーザーは認証が必要なページにアクセスしようとした

**ユーザーの操作**
1. 未ログイン状態で、認証が必要なページのURLにアクセスする
2. ログインページにリダイレクトされる
3. 正しい認証情報を入力してログインする

**期待される動作**
- ログインが成功した場合：
  - 元々アクセスしようとしていたページにリダイレクトされる
  - ユーザーは目的のページに到達できる

## 4. 非機能要件

### 4.1 セキュリティ要件

- パスワードはハッシュ化してデータベースに保存する（bcrypt等を使用）
- ログイン試行回数に制限を設ける（ブルートフォース攻撃対策）
- セッション（またはJWTトークン）は適切な有効期限を設定する
- HTTPS通信を使用する（本番環境）
- パスワード入力欄はマスク表示する
- エラーメッセージは、ユーザー存在の有無を推測できないようにする

### 4.2 パフォーマンス要件

- ログイン処理のレスポンスタイムは2秒以内を目標とする
- データベースクエリは適切にインデックスを設定して最適化する

### 4.3 ユーザビリティ要件

- ログインフォームは直感的で使いやすいUIを提供する
- エラーメッセージは明確で理解しやすい
- ローディング状態を適切に表示する
- パスワードの表示/非表示を切り替えられる機能を提供する（オプション）

## 5. データモデル

### 5.1 ユーザーテーブル（users）

| カラム名 | 型 | 制約 | 説明 |
|---------|-----|------|------|
| id | INT | PRIMARY KEY, AUTO_INCREMENT | ユーザーID |
| email | VARCHAR(255) | UNIQUE, NOT NULL | メールアドレス |
| username | VARCHAR(100) | UNIQUE, NOT NULL | ユーザー名（オプション） |
| password_hash | VARCHAR(255) | NOT NULL | ハッシュ化されたパスワード |
| created_at | DATETIME | NOT NULL | 作成日時 |
| updated_at | DATETIME | NOT NULL | 更新日時 |

### 5.2 セッションテーブル（sessions）（オプション）

| カラム名 | 型 | 制約 | 説明 |
|---------|-----|------|------|
| id | VARCHAR(255) | PRIMARY KEY | セッションID |
| user_id | INT | FOREIGN KEY, NOT NULL | ユーザーID |
| expires_at | DATETIME | NOT NULL | 有効期限 |
| created_at | DATETIME | NOT NULL | 作成日時 |

## 6. API仕様（概要）

### 6.1 ログインAPI

- **エンドポイント**: `POST /api/auth/login`
- **リクエストボディ**:
  ```json
  {
    "email": "user@example.com",
    "password": "password123"
  }
  ```
- **レスポンス（成功）**: `200 OK`
  ```json
  {
    "success": true,
    "token": "jwt_token_here",
    "user": {
      "id": 1,
      "email": "user@example.com",
      "username": "username"
    }
  }
  ```
- **レスポンス（失敗）**: `401 Unauthorized`
  ```json
  {
    "success": false,
    "message": "メールアドレスまたはパスワードが正しくありません"
  }
  ```

### 6.2 ログアウトAPI

- **エンドポイント**: `POST /api/auth/logout`
- **認証**: 必要（JWTトークンまたはセッション）
- **レスポンス（成功）**: `200 OK`
  ```json
  {
    "success": true,
    "message": "ログアウトしました"
  }
  ```

### 6.3 認証状態確認API

- **エンドポイント**: `GET /api/auth/me`
- **認証**: 必要（JWTトークンまたはセッション）
- **レスポンス（成功）**: `200 OK`
  ```json
  {
    "success": true,
    "user": {
      "id": 1,
      "email": "user@example.com",
      "username": "username"
    }
  }
  ```
- **レスポンス（未認証）**: `401 Unauthorized`
  ```json
  {
    "success": false,
    "message": "認証が必要です"
  }
  ```

## 7. 実装の優先順位

1. **Phase 1（基本機能）**
   - ログインフォームの作成
   - ログインAPIの実装
   - 基本的な認証フロー

2. **Phase 2（セキュリティ強化）**
   - パスワードハッシュ化
   - セッション管理
   - エラーハンドリング

3. **Phase 3（UX改善）**
   - ローディング状態の表示
   - エラーメッセージの改善
   - リダイレクト機能

4. **Phase 4（高度な機能）**
   - セッションタイムアウト処理
   - ログイン試行回数制限
   - パスワード表示/非表示切り替え

## 8. テストケース一覧

| テストケースID | シナリオ | 優先度 |
|---------------|---------|--------|
| TC-001 | 正常なログイン | 高 |
| TC-002 | パスワード誤りでのログイン失敗 | 高 |
| TC-003 | ユーザー不存在でのログイン失敗 | 高 |
| TC-004 | 入力検証エラー | 高 |
| TC-005 | 既ログイン状態でのログインページアクセス | 中 |
| TC-006 | 正常なログアウト | 高 |
| TC-007 | セッションタイムアウト | 中 |
| TC-008 | 未ログイン状態での保護ページアクセス | 高 |
| TC-009 | ログイン後の元ページリダイレクト | 中 |

## 9. 備考

- 本要件定義は初期バージョンであり、開発の進行に伴って更新される可能性があります
- セキュリティ要件は、本番環境での運用を考慮して設定されています
- ユーザビリティ要件は、実際のユーザーテストを通じて改善していく予定です

